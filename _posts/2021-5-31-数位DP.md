---
layout:     post
title:      数位DP
subtitle:   一些常见的套路的数位DP题
date:       2021-5-26
author:     weixi zhang
header-img: img/IMG_2830.JPG
catalog: false
tags:
    - 动态规划
---

### 数位DP 

顾名思义，一种和数位有关的DP，常见于计数问题中，本人是第一次学习，所以内容较为简单，略微啰嗦。

本文采用记忆化搜索的方式来实现数位DP。

今年的区域赛貌似出现了两次数位DP，都不是金牌及以上的题目,所以打脸了我认为数位DP又偏又不可能出题的幼稚想法。

<b>好像一般的数位DP都比较套路？</b>

<h5>HDU - 2089</h5>

一道入门的数位DP题，和windy数一样的。

<b>题意：</b>

查询区间[L,R]满足条件的数的个数：

条件：数字中不能出现4，且不能出现62

<b>题解：</b>

实际上求解[1,R]上满足条件的数减去[1,L-1]上满足条件的数就可以了。那么如何求解这样的问题呢？从<b>最高位开始计算！！！</b>

例如对于<b>231756</b>这样的数来说，用<b>dp[i] [j] [k]</b>来表示当前所在位是第<b>i</b>位，上一位的数字位<b>j</b>，且上一位是否为最高位(如果为最高位的话k等于1，否则为0)。

例如我们已经处理了<b>106???</b>这样的数，在我们处理到<b>206???</b>这样的数的时候，会发现后面的情况已经处理掉了，就可以直接返回了，这一步就是用记忆化搜索完成的。对于上一位是<b>k</b>来说，如果为<b>0</b>的话，显然当前位的<b>k</b>是不可能取到1的，所以当前位是可以取到最大值<b>9</b>的。<b>当且仅当上一位的k是1时，此时才只能取到原来的数231756在该位的上限。</b>

<b>AC代码:</b>

```HTML
#include "bits/stdc++.h"
using namespace std;
const int N = 15;
int L, R;
int dp[N][N][2];
int num[N], cnt;
int dfs(int pos, int last, int limit) {
    int ans = 0;
    if (pos == cnt) return 1;
    if (dp[pos][last][limit] != -1) return dp[pos][last][limit];

    for (int j = 0; j <= (limit ? num[pos] : 9); j++) {
        if (last == 6 && j == 2 || j == 4) continue;
        ans += dfs(pos + 1, j, limit && j == num[pos]);
    }
    dp[pos][last][limit] = ans;
    return ans;
}

int query(int x) {
    memset(dp, -1, sizeof dp);
    cnt = 0;
    while (x) num[cnt] = x % 10, x /= 10, cnt++;
    reverse(num, num + cnt);
    return dfs(0, 12, 1);
}
int main() {
    while (scanf("%d %d", &L, &R) != EOF && (L || R)) {
        printf("%d\n", query(R) - query(L - 1));
    }

    return 0;
}
```

